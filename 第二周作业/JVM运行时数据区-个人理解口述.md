# 题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

*   堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存

&#x9;	线程共享区	&#x9;

&#x9;		堆：存储new出来的对象和数组。是GC主要的内存区，可逻辑分为老年代和新生代，其比例为2:1，新生代又分为edun、s0、s1,其比例为8:1:1。

&#x9;		方法区：存储虚拟机加载的class文件信息，常量，静态变量，编译器编译后的代码缓存。其中常量池可分为三种，

&#x9;		一个是class常量池，一个类有一个类class常量池，主要存储类元信息。

&#x9;		一个是运行时常量池，一个类有一个运行时常量池，主要储存。

&#x9;		一个是字符串常量池，JVM全局只有一个字符串常量池。

&#x9;	线程私有区

&#x9;		虚拟机栈：当线程创建的时候，虚拟机栈跟随创建，当线程结束，虚拟机栈也会结束。当一个方法被调用的时候会创建一个栈帧，当方法执行结束，栈帧也会结束。

&#x9;		本地方法栈：可以理解为由native修饰的方法。因为JVM是建立在操作系统之上的应用，通过本地方法栈可以去调度C或者C++的方法，达到和操作系统之间的交互。

&#x9;		程序计数器：用于标记虚拟机栈当前执行的自己指令位置，用于多线程之间的上下文切换。

*   为什么堆内存要分年轻代和老年代？

    &#x9;基于两个分代假说：1.大多数对象都是朝生熄灭的；2.活的越久的对象越难消灭。

    &#x9;基于以上假设，设计出了多款垃圾收集器。然而将堆分成年轻代和老年代，GC的时候可以对不同代的内存空间使用不同的垃圾收集策略，从而降低内存开销和提高垃圾收集时间。

&#x9;&#x9;

# 题目 02- 描述一个 Java 对象的生命周期

*   解释一个对象的创建过程

&#x9;	1.类加载：当创建一个类的时候，会先去检查是否已经加载过，如果没有，则先去class文件加载该类

&#x9;	2.验证：加载完class文件后，会去校验class的合法性。

&#x9;	3.准备：生成一个类，将所有属性赋默认值。

&#x9;	4.解析：解析类中的常量和变量，指向对应的常量池，也就是句柄引用。

&#x9;	5.初始化：对各个属性赋予真实的数值。

&#x9;	6.使用：使用该对象

&#x9;	7.卸载：GC回收该对象

&#x9;	&#x9;

*   解释一个对象的内存分配

&#x9;	1.首先去edun区分配内存空间，如果edun区内存够，则分配内存（年轻代），如果内存不够，则进行一侧YGC，然后在判断edun空间内存空间是否够，够的话，则分配内存（年轻代）。

&#x9;	2.基于1，如果内存还是不够，对象将试图晋升老年代。如果老年代内存够，则晋升老年代，如果不够，则会进行一次FGC,.如果老年代内存够，则晋升老年代成功。如果老年代内存还不够，

&#x9;		则发生OOM.

*   解释一个对象的销毁过程

&#x9;	JVM会对那些内存中没有被引用的对象进行垃圾收集。主要有两种判断一个对象是否是垃圾的算法，一个是引用计数法，一个是根可达算法。判定一个对象是否被垃圾收集器回收，至少经

&#x9;	历两次标记过程。第一次标记：如果对象可达性分析后，发现它没有与GC Roots相连接的引用链，它会第一次被标记。第二次标记：第一次标记后，接着会根据它是否有必要执行finalize()

&#x9;	方法进行一次筛选。在finalize()方法中没有重新与引用链建立关联关系的，将被第二次标记，如果被第二次标记，将会被垃圾回收，否则会继续存活。

*   对象的 2 种访问方式是什么？

&#x9;	一种是句柄访问，句柄指向具体的对象地址，通过访问句柄，然后在访问对象，多了一层寻址，所以访问较直接访问慢，优点是比较稳定；一种是直接指针访问，直接通过对象地址访问，。

*   为什么需要内存担保？

&#x9;	当新生代无法分配内存的时候，会将新生代中的老对象转移到老年代，然后将新对象放入新生代中，这种内存分配机制叫做内存担保。如我们知道的，新生代中的对象是通过复制收集算法。

&#x9;	如果有大对象在进行YGC之后仍然存活，但是新生代中的s0和s1内存空间较小，这样就会导致大对象在s0和s1之间无法复制。这个时候需要老年代来做担保，将新生代中无法放下的大对象

&#x9;	放入老年代中，当然，前提是老年代有足够的空间。

# 题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

*   ParNew 收集器

    &#x20; 垃圾收集算法：新生代用复制算法，老年代用的标记-整理算法。

&#x9;	实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的基本都和Serial保持一致。

*   ParallelScavenge 收集器

&#x9;	它是基于标记-复制算法实现的年轻代收集器，也是能够并行收集的多线程收集器。目标则是达到一个可控制的吞吐量

*   ParallelOld 收集器

&#x9;	它是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

*   CMS 收集器

&#x9;	它是一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现的。

执行过程：1.初始标记。2.并发标记。3.重新标记。4.并发清除

*   G1 收集器

&#x9;	它把连续的Java堆划分为多个大小相等的独立区域，每一个Region都可以根据需要，扮演新生代的Eden空间，Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经			存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

&#x9;	执行过程：1.初始标记。2.并发标记。3.最终标记。4.筛选回收
